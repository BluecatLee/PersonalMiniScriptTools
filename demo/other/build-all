#! /bin/sh -
# build one or several packages on one or several hosts, in parallel process style.

# Grammer:
#       build-all [ --? ]
#                 [ --all "..." ]
#                 [ --cd "..." ]
#                 [ --check "..." ]
#                 [ --configure "..." ]
#                 [ --environment "..." ]
#                 [ --help ]
#                 [ --logdirectory dir ]
#                 [ --on "[user@]host[:dir][,envfile] ..." ]
#                 [ --source "dir..." ]
#                 [ --userhosts "file(s)" ]
#                 [ --version ]
#                 package(s)

# Available init files:
#       $HOME/.build/directories        list of source directories
#       $HOME/.build/userhosts          list of [user@]host[:dir][,envfile]

IFS='
        '

PATH=/usr/local/bin:/bin:/usr/bin
export PATH

# set permission mask
UMASK=002
umask $UMASK

build_one() {
	# Grammer
	# 	build_one [user@]host[:build-directory][,envfile]
	arg="`eval echo $1`"
	
	userhost="`echo $arg | sed -e 's/:.*$//'`"
	
	user="`echo $userhost | sed -e s'/@.*$//'`"
	test "$user" = "$userhost" && user=$USER
	
	host="`echo $userhost | sed -e s'/^[^@]*@//'`"
	
	envfile="`echo $userhost | sed -e s'/^[^,]*,//'`"
	test "$envfile" = "$arg" && envfile=/dev/null
	
	builddir="`echo $arg | sed -e s'/^.*://' -e 's/,.*//'`"
	test "$builddir" = "$arg" && builddir=/tmp
	
	parbase=`basename $PARFILE`
	
	# 如果这些模式被更换过 则更新find_package()
	package="`echo $parbase | \
					sed -e 's/[.]jar$//' \
						-e 's/[.]tar[.]bz2$//' \
						-e 's/[.]tar[.]gz$//' \
						-e 's/[.]tar[.]Z$//' \
						-e 's/[.]tar$//' \
						-e 's/[.]tgz$//' \
						-e 's/[.]zip$//'`"
						
	# 如果我们在远程主机上看不到包文件 则复制过去
	echo $SSH $SSHFLAGS $userhosts "test -f $PARFILE"
	if $SSH $SSHFLAGS $userhosts "test -f $PARFILE"
	then 
		parbaselocal=$PARFILE
	else
		parbaselocal=$parbase
		echo $SCP $PARFILE $userhost:$builddir
		$SCP $PARFILE $usrhosts:$builddir
	fi
	
	# 在远程主机上解开存档文件、构建，及以后台执行方式检查它
	sleep 1 #为了保证唯一的日志文件名
	now="`date $DATEFLAGS`" 
	logfile="$package.$host.$now.log"
	nice $SSH $SSHFLAGS $userhost "
			echo '=========================================================' ;
			test -f $BUILDBEGIN && . $BUILDBEGIN || test -f $BUILDBEGIN && source $BUILDBEGIN || true ;
			echo 'Package:				$package' ;
			echo 'Archive:				$PARFILE' ;
			echo 'Date:					$now' ;
			echo 'Local user:			$USER' ;
			echo 'Local host:			`hostname`' ;
			echo 'Local log directory:	$LOGDIR' ;
			echo 'Local log file:		$logfile' ;
			echo 'Remote user:			$user' ;
			echo 'Remote host:			$host' ;
			echo 'Remote directory:		$builddir' ;
			printf 'Remote date:			' ;
			date $DATEFLAGS ;
			printf 'Remote uname:			' ;
			uname -a || true ;
			printf 'Remote gcc version:		' ;
			gcc --version | head -n 1 || echo ;
			printf 'Remote g++ version:		' ;
			g++ --version | head -n 1 || echo ;
			echo 'Configure environment:`$STRIPCOMMENTS $envfile | $JOINLINES`' ;
			echo 'Extra environment:	$EXTRAENVIRONMENT' ;
			echo 'Configure directory:	$CONFIGUREDIR' ;
			echo 'Configure flags:		$CONFIGUREFLAGS' ;
			echo 'Make all targets；	$ALLTARGETS' ;
			echo 'Make check targets:	$CHECKTARGETS' ;
			echo 'Disk free report for $builddir/$package:' ;
			df $builddir | $INDENT ;
			echo 'Environment:' ;
			env | env LC_ALL=C sort | $INDENT ;
			echo '=========================================================' ;
			umask $UMASK ;
			cd $builddir || exit 1;
			/bin/rm -rf $builddir/$package ;
			$PAR $parbaselocal ;
			test "$parbase" = "$parbaselocal" && /bin/rm -rf $parbase ;
			cd $package/$CONFIGUREDIR || exit 1 ;
			test -f configure && chmod a+x configure && env `$STRIPCOMMENTS $envfile | $JOINLINES` \
				$EXTRAENVIRONMENT nice time ./configure $CONFIGUREFLAGS ;
			nice time make $ALLTARGETS && nice time make $CHECKTARGETS ;			
			echo '=========================================================' ;
			echo 'Disk free report for $builddir/$package:' ;
			df $builddir | $INDENT ;
			printf 'Remote date:			' ;
			date $DATEFLAGS ;
			cd ;
			test -f $BUILDEND && . $BUILDEND || test -f $BUILDEND && source $BUILDEND || true ;
			echo '=========================================================' ;
		" < /dev/null > "$LOGDIR/$logfile" 2>1& &						
}

error() {
	echo "$@" 1>&2
	usage_and_exit 1
}

find_file() {
	# Grammer	
	# 	find_file file program-and-args
	if test -r "$1"
	then
		PAR="$2"
		PARFILE="$1"
		return 0
	else
		return 1
	fi
}

find_packages() {
	# Grammer
	# 	find_package package-x.y.z
	base=`echo "$1" | sed -e 's/[-_][.]*[0-9].*$//'`
	PAR=
	PARFILE=
	for srcdir in $SRCDIRS
	do
		test "$srcdir" = "." && srcdir="`pwd`"
		
		for subdir in "$base" ""
		do
			# 如果此列表改变 则更新build_one()内的包设置
			find_file $srcdir/$subdir/$1.tar.gz  "tar xfz"  && return
			find_file $srcdir/$subdir/$1.tar.Z   "tar xfz"  && return
			find_file $srcdir/$subdir/$1.tar     "tar xf"   && return
			find_file $srcdir/$subdir/$1.tar.bz2 "tar xfj"  && return
			find_file $srcdir/$subdir/$1.tar.tgz "tar xfz"  && return
			find_file $srcdir/$subdir/$1.tar.zip "unzip -q" && return
			find_file $srcdir/$subdir/$1.tar.jar "jar xf"   && return
		done
	done
}

set_userhosts() {
	# Grammer
	# 	set_userhosts file(s)
	for u in "$@"
	do
		if test -r "$u"
		then
			ALTUSERHOSTS="$ALTUSERHOSTS $u"
		elif test -r "$BUILDHOME/$u"
		then
			ALTUSERHOSTS="$ALTUSERHOSTS $BUILDHOME/$u"
		else
			error "File not found: $u"
		fi
	done
}

usage() {
	cat << EOF
Usage:
		$PROGRAM [--?]
						[ --all "..." ]
						[ --cd "..." ]
						[ --check "..." ]
						[ --configure "..." ]
						[ --environment "..." ]
						[ --help ]
						[ --logdirectory dir ]
						[ --on "[user@]host[:dir][,envfile] ..." ]
						[ --source "dir..." ]
						[ --userhosts "file(s)" ]
						[ --version ]
EOF
}

usage_and_exit() {
	usage
	exit $1
}

version() {
	echo "$PROGRAM version $VERSION"
}

warning() {
	echo "$@" 1>&2
	EXITCODE=`expr $EXITCODE + 1`
}
    
# 程序名称
PROGRAM=`basename $0`
# 版本编号
VERSION=1.0
# 时间戳
DATEFLAGS="+%Y.%m.%d.%H.%M.%S"

# 默认使用ssh scp连接远程主机
# 对于旧式不安全的远程shell站点 可以更换为rsh rcp
SSH=ssh
SCP=scp
# 关闭ssh建立加密通道供X Window System流量使用的功能
SSHFLAGS=${SSHFLAGS--x}

	
# 程序或mark target构建用	
ALLTARGETS=
# 日志文件的另一个位置
altlogdir=
# 来源文件的另一个位置
altsrcdirs=
# 列出额外主机的文件
ALTUSERHOSTS=

# 构建开始时在远程主机的登录shell内执行 提供进一步的定制和日志文件的报告
BUILDBEGIN=./.build/begin
# 构建结束时在远程主机登录shell内执行
BUILDEND=./.build/end
# 初始化文件所在目录
BUILDHOME=$HOME/.build

# 执行包测试的make target名称
CHECKTARGETS=check
# 配置脚本的子目录
CONFIGUREDIR=.
# 配置程序的标识
CONFIGUREFLAGS=


# 默认的额外环境变量
EXTRAENVIRONMENT=

# 将数据流过滤成内缩状(格式化输出) 此处将每行缩进3个制表符
# awk
# 	$0表示整个记录
INDENT="awk '{ print \"\t\t\t\" \$0 }'"
# 将换行字符置换为空格(\040:空格的8进制的ascii值)
JOINLINES="tr '\n' '\040'"


# 本地日志目录
LOGDIR=




# 去掉注释
STRIPCOMMENTS='sed -e s/#.*$//'
# 在命令行上指定额外的构建主机
userhosts=

# 退出码
EXITCODE=0

# default init files
defaultdirectories=$BUILDHOME/directories
defaultuserhosts=$BUILDHOME/userhosts

# 寻找包分发的位置列表 如果用户未提供个人化列表 则使用默认列表
# 去除初始化文件的注释 如果内容为空 则使用默认列表
SRCDIRS="`$STRIPCOMMENTS $defaultdirectories 2> /dev/null`"
test -z "$SRCDIRS" && \
	SRCDIRS="
		/usr/local/src
		/usr/local/gnu/src
		$HOME/src
		$HOME/gnu/src
		/tmp
		/usr/tmp
		/var/tmp
	"

# $#: 参数个数
while test $# -gt 0
do
	case $1 in
		--all | --al | --a | -all | -al | -a )
			shift
			ALLTARGETS="$1"
			;;
		--cd | -cd )
			shift 
			CONFIGUREDIR="$1"
			;;
		--check | --chec | --che | --ch | -check | -chec | -che | -ch )
			shift
			CHECKTARGETS="$1"
			;;
		--configure | --configur | --configu | --config | --confi | --conf | --con | --co | \
		-configure | -configur | -configu | -config | -confi | -conf | -con | -co )
			shift
			CONFIGUREFLAGS="$1"
			;;
		--environment | --environmen | --environme | --environm | --environ | --enviro | --envir \
		--envi | --env | --en | --e | -environment | -environmen | -environme | -environm | -environ \
		-enviro | -envir | -envi | -env | -en | -e )
			shift
			EXTRAENVIRONMENT="$1"
			;;
		--help | --hel | --he | --h | '--?' | -help | -hel | -he | -h | '-?' )
			usage_and_exit 0
			;;
		--logdirectory | --logdirector | --logdirecto | --logdirect | --logdirec | --logdire | --logdir \
		--logdi | --logd | --log | --lo | --l | -logdirectory | -logdirector | -logdirecto | -logdirect \
		-logdirec | -logdire | -logdir | -logdi | -logd | -log | -lo | -l )
			shift
			altlogdir="$1"
			;;
		--on | --o | -on | -o )
			shift
			userhosts="$userhosts $1"
			;;
		--source | 	--sourc | --sour | --sou | --so | --s | -source | -sourc | -sour | -sou | -so | -s )
			shift	
			altsrcdirs="$altsrcdirs $1"
			;;
		--userhosts	 | --userhost | --userhos | --userho | --userh | --user | --use | --us | --u \
		-userhosts | -userhost | -userhos | -userho | -userh | -user | -use | us | -u )
			shift
			set_userhosts $1
			;;
		--version | --versio | --versi | --vers | --ver | --ve | --v | -version | -versio | -versi | vers \
		-ver | -ve | -v )
			version
			exit 0
			;;
		-*)
			error "Unrecognized option: $1"
			;;
		*)
			break
			;;
	esac
	shift
done

# 寻找适当的邮件客户端程序
for MAIL in /bin/mailx /usr/bin/mailx /usr/sbin/mailx /usr/ucb/mailx /bin/mail /usr/bin/mail
do	
	test -x $MAIL && break
done
test -x $MAIL || error "Cannot find mail client"

# 命令行来源目录优先于默认值
SRCDIRS="$altsrcdirs $SRCDIRS"

if test -n "$userhosts"
then
	test -n "$ALTUSERHOSTS" && userhosts="$userhosts `$STRIPCOMMENTS $ALTUSERHOSTS 2> /dev/null`"
else
	test -z "$ALTUSERHOSTS" && ALTUSERHOSTS="$defaultuserhosts"
	userhosts="`$STRIPCOMMENTS $ALTUSERHOSTS 2> /dev/null`"
fi

# 检查是否要执行某些操作
test -z "$userhosts" && usage_and_exit 1

for p in "$@"
do
	find_package "$p"
	
	if test -z "$PARFILE"
	then
		warning "Cannot find package file $p"
		continue
	fi

	LOGGER="$altlogdir"
	if test -z "$LOGDIR" -o ! -d "$LOGDIR" -O ! -w "$LOGDIR"
	then 
		for LOGDIR in "`dirname $PARFILE`/logs/$p" $BUILDHOME/logs/$p /usr/tmp /var/tmp /tmp
		do 
			test -d "$LOGDIR" || mkdir -p "$LOGDIR" 2> /dev/null
			test -d "$LOGDIR" -a -w "$LOGDIR" && break
		done
	fi	
	
	msg="Check build logs for $p in `hostname`:$LOGDIR"
	echo msg
	echo "$msg" | $MAIL -s "$msg" $USER 2> /dev/null
	
	for u in $userhosts
	do
		build_one $u
	done
done	

test $EXITCODE -gt 125 && EXITCODE=125

exit $EXITCODE 